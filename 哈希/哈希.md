---
show: step
version: 1.0
enable_checker: true
---

# 哈希的介绍

## 哈希

本节内容从介绍哈希的基本概念 。主要包含数论基础，介绍哈希表的介绍及实现，双哈希，以及数据加密算法。

#### 知识点

+ 哈希的概念
+ 数论基础
+ 哈希表的介绍及实现
+ 双哈希
+ 数据加密算法

## 哈希的概念

#### 什么是哈希

哈希(Hash)，一般翻译做散列、杂凑，或音译为哈希，是把任意长度的输入（又叫做预映射 pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。

#### 概念介绍

若结构中存在和关键字 K 相等的记录，则必定在 f(K)的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系 f 为**散列函数(Hash function)**，按这个事先建立的表为**散列表**.

对不同的关键字可能得到同一散列地址，即 key1≠key2，而 f(key1)=f(key2)，这种现象称**碰撞**。具有相同函数值的关键字对该散列函数来说称做**同义词**。综上所述，根据散列函数 H(key)和处理冲突的方法将一组关键字映象到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“象” 作为记录在表中的存储位置，这种表便称为**散列表**，这一映象过程称为散列造表或散列，所得的存储位置称**散列地址**。

若对于关键字集合中的任一个关键字，经散列函数映象到地址集合中任何一个地址的概率是相等的，则称此类散列函数为**均匀散列函数(Uniform Hash function)**，这就是使关键字经过散列函数得到一个“随机的地址”，从而减少冲突。

## 数论基础

素数，也称质数，只包含两个因数，且一个因数为 1，一个因数为它本身。

素数有以下性质：

+ 素数 p 的因子有且只有两个：1 和 p

+ 素数一定是奇数

+ 任意一个大于 1 的正整数 N，一定可以质因式分解为它的有限个质因子之积

+ 素数的个数是无限的

+ 所有大于 10 的素数中，其个位数只能是 1,3,7,9 其中之一

+ 一个充分大的偶数一定可以写成：一个素数加上一个最多由 2 个质因子所组成的合成数

#### 判断素数

寻找素数算法，有很多种，包括短除法，筛选法两种。

**短除法**

设计思想：最直接的方法就是从定义出发，对于任意整数 p，用[2，p-1]去整除 p，如果发现 p 可以被整除，p 就不是素数

下面给出短除法的参考代码。

```python
def find_prime(num):
    if num > 1:# 查看因子
        for i in range(2,num):
            if (num % i) == 0:
                print(num,"不是质数")
                print(i,"乘于",num//i,"是",num)
                break
        else:
            print(num,"是质数")
    else:
        print(num,"不是质数")# 如果输入的数字小于或等于 1，不是
num = int(input("请输入一个数字: "))
find_prime(num)
```

效果如下：

显然，这个方法的效率简直低的让人难以接受，优化空间非常大

**筛选法**

设计思想：

1. 将 n 个数字全部放进数组，并都置为肯定状态

2. 将数组下标是偶数的数字全部置为否定状态

3. 依次遍历数组长度的平方根个数字

4. 如果当前数字处于被肯定的状态，则将其倍数的数字状态置为否定

```python
def find_prime_2(num):
    primes_bool=[False,False]+[True]*(n-1)
    for i in range(3,len(primes_bool)):
        if i&1==0:
            prims_bool[i]=False
    for i in range(3,int(math.sqrt(n))+1):
        if prims_bool[i] is True:
            for j in range(i+j,n+1,i):
                prims_bool[j]=False
    prims=[]
    [prims.append(i) for i,v in enumerate(prims_bool) if v is True]
    return prims
